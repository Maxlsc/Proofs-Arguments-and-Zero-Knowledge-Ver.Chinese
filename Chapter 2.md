# Proofs, Arguments, and Zero-Knowledge第二章中文翻译

本章标题：《The Power of Randomness: Fingerprinting and Freivalds’ Algorithm》

## 2.1 Reed Solomon 指纹识别

该部分涉及的证明系统的效率和能力很大程度上源自于其随机性。在具体讨论这些证明系统之前，我们需要先建立对随机性能力的认识——它可以惊人地提升特定算法的效率。作为引入和介绍，在本节中，不存在不诚实的证明者和计算能力弱的验证者。相反，我们考虑Alice和Bob两方，这两方互相信任，并希望相互合作来共同计算某个特定的函数。

### 2.11 一些设定

Alice和Bob分别住在一个国家的两端。他们各持有一个字符数为$$n$$的大文件（出于准确性考虑，假设字符均为ASCII字符，因此共有128种可选的字符）。我们将Alice的文件记为字符序列$$(a_1,...,a_n)$$，将Bob的文件记为$$(b_1,..,b_n)$$，两方的交互目标是确认他们的文件是否“**相等**”，也即对于任意的$$i=1,...,n$$，是否有$$a_i=b_i$$。考虑到文件很大，他们希望尽量减少“**交互**”，也即Alice希望需要发给Bob的有关她的文件的信息越少越好。

​	一个显然的方案是Alice将整个文件发送给Bob，然后Bob检查对于任意的$$i=1,...,n$$，是否有$$a_i=b_i$$，但是这要求Alice向Bob发送全部的$$n$$个字符，因为$$n$$太大了，所以这个方法不可行。这说明没有**确定性**的程序可以比这个显然的方案需要发送的信息更少。

​	但是，如果Alice和Bob可以运行一组错误率极小（例如最多0.0001）的**随机性**的程序，那么交互的信息量就可以大大减少。

### 2.1.2 交互协议

**The High-Level Idea.** 一个粗略的想法是，Alice在一个（小）hash函数族$$\mathcal{H}$$中随机挑选一个hash函数$$h$$，考虑把$$h(x)$$作为$$x$$的一个很短的“指纹”。通过“指纹”这个名字，我们可以认为$$h(x)$$是$$x$$的一个“近乎唯一的标识”，也即对任意的$$y\neq x$$，在随机选择$$h$$的情况下，$$x$$和$$y$$的指纹很大概率是不一样的。形式化的表示如下：
$$
\begin{aligned}
\forall x\neq y,\mathop{\text{Pr}} \limits_{h\in\mathcal{H}}[h(x)=h(y)]\leq0.0001.
\end{aligned}
$$
​	Alice并不直接向Bob发送整个文件，而是将$$h$$和$$h(a)$$发给Bob。 Bob检查是否$$h(a)=h(b)$$。如果$$h(a)\neq h(b)$$，那么Bob就**知道**了$$a\neq b$$；同时当$$h(a)=h(b)$$时，Bob就可以基本确定（但不是100%确信）$$a=b$$。

**The Detials.** 为了具体实现上面描述的方案，我们选定一个素数$$p\geq\text{max}\{m,n^2\}$$，令$$\mathbb{F}_p$$表示模$$p$$的整数集合。在本节的剩余部分，我们假设所有的计算都是在**模$$p$$**下进行的。这意味着所有数都会被其除以$$p$$的余数代替。例如，若$$p=17$$，则有$$(2\cdot3^2+4)\ (\text{mod}\ 17)=22(\text{mod}\ 17)-5$$。

​	规定$$p$$需要大于$$n^2$$的原因是，我们接下来介绍的协议的错误率小于$$n/p$$，并且我们希望这个量（$$n/p$$）的上界是$$1/n$$（选择更大的$$p$$会让错误率更小）。而$$p$$需要大于字符表大小$$m$$的原因是，下面的协议将Alice和Bob的输入看作$$\mathbb{F}_p^n$$上的向量，并且比对两方的向量是否相等。这意味着我们需要将Alice和Bob输入的所有可能字符与$$\mathbb{F}_p$$中的元素关联起来，这要求$$p\geq m$$。

​	对于每个$$r\in\mathbb{F}_p$$，定义$$h_r(a_1,...,a_n)=\Sigma_{i=1^n}a_i\cdot r^{i-1}$$。我们接下来考虑的hash函数族$$\mathcal{H}$$为
$$
\begin{align}
\mathcal{H}=\{h_r:r\in\mathbb{F}_p\} \tag{2.1}
\end{align}
$$
​	直观来看，每个hash函数$$h_r$$将输入$$(a_1,...,a_n)$$看作是一个$$n-1$$维多项式的系数，则输出为这个多项式在$$r$$上的值。也就是说，在我们的交互方案中，Alice在$$\mathbb{F}_p$$中挑选一个随机元素$$r$$，并计算$$v=h_r(a)$$，然后将$$v$$和$$r$$发送给Bob。Bob在$$v=h_r(b)$$时输出相等（EQUAL），否则输出不相等（NOT-EQUAL）。

### 2.1.3 对协议的分析

下面，我们证明该方案以极高的概率输出正确结果。具体而言，有如下两个性质：

- 如果对所有的$$i=1,...,n$$，都有$$a_i=b_i$$，那么无论$$r$$取到哪一个可能的值，Bob都会输出EQUAL。
- 如果有至少一个$$i$$使得$$a_i\neq b_i$$，那么Bob都会以至少$$1-(n-1)/p$$的概率输出NOT-EQUAL，由于$$p\geq n^2$$，该概率至少为$$1-1/n$$。

​	第一个性质的正确性显而易见：如果$$a=b$$，那么显然对任意可能的$$r$$都有$$h_r(a)=h_r(b)$$。第二个性质的正确性基于下面的关键事实（Fact），我们将在[2.1.6](#2.1.6)节中给出该事实的证明。

<span id="Fact2.1.">**Fact 2.1.**</span> 对任意两不同（distinct、unequal）的最大维数为$$n$$的多项式$$p_a,p_b\in\mathbb{F}_p^n$$，至多有$$n$$个不同的$$x\in\mathbb{F}_p$$使得$$p_a(x)=p_b(x)$$。

​	令$$p_a(x)=\Sigma_{i=1}^na_i\cdot x^{i-1}$$，类似的，令$$p_b(x)=\Sigma_{i=1}^nb_i\cdot x^{i-1}$$。注意到$$p_a、p_b$$都是$$x$$的最多$$n-1$$维的多项式。Alice在交互协议中发送给Bob的值$$v$$就是$$p_a(r)$$，而Bob对比的值为$$p_b(r)$$​。

​	根据 Fact [2.1](#Fact2.1.)，如果至少有一个$$i$$使得$$a_i\neq b_i$$，那么$$r$$最多有$$n-1$$种取值使得$$p_a(r)=p_b(r)$$。考虑到$$r$$是在$$\mathbb{F}_p$$中随机选择的，因此Alice选到这种$$r$$的概率最大为$$(n-1)/p$$。因此，Bob以至少$$1-(n-1)/p$$的概率输出NOT-EQUAL（此处的概率基于$$r$$选择的随机性）。

### 2.1.4 协议的开销

在整个协议中，Alice向Bob发送了两个$$\mathbb{F}_p$$上的元素，也即$$v$$和$$r$$。从bits的角度来说，假设对于某个常数$$c$$，有$$p\leq n^c$$，那么这里的空间开销就是$$O(\text{log}\ n)$$ bits。相较于需要发送$$n\cdot \text{log}\ m$$ bits的确定性协议而言，随机性协议有**指数级的改进**（除非另有明确规定，本手稿中所有对数均以2为底）。这深刻的展示了随机性的能力。

### 2.1.5 讨论

我们称上述协议为 Reed-Solomon 指纹识别（fingerprinting），因为$$p_r(a)$$实际上是向量$$(a_1,...,a_n)$$的纠错码中的一个随机条目。该编码被称为Reed-Solomon编码。已知的还有一些其他的指纹识别模式。事实上，我们对上述协议中所使用的hash族$$\mathcal{H}$$的要求只有$$\forall x\neq y,\text{Pr}_{h\in\mathcal{H}}[h(x)=h(y)]$$足够小。很多已知的hash族都满足这一性质，但由于Reed-Solomon指纹识别的代数结构，其被证明与概率证明系统的研究有很大的相关性。

**A few sentences on finite fields.** （有关有限域）**域**（field）是具有加、减、乘、除四种运算的集合，且这些运算与有理数的运算大致相同。因此，举例而言，所有实数构成一个域，因为对于任意的两个实数$$c$$和$$d$$，$$c+d、c-d、c\cdot d、c/d$$​均为实数。相同的，复数和有理数都构成域。但全体整数并**不能**构成域，因为两个整数相除的结果不一定是整数。

​	对任意的素数$$p$$，$$F_p$$也是一个域（而且是有限的）。此处域上的运算就是模$$p$$下的加、减、乘、除。我们对除法做如下解释：对任意的$$a\in\mathbb{F}_p$$\ $$\{0\}$$，存在一个唯一的元素$$a^{-1}\in\mathbb{F}_p$$使得$$a\cdot a^{-1}=1$$。例如，如果$$p=5,a=3$$，那么$$a^{-1}=2$$，因为$$3\cdot 2(\text{mod}\ 5)=6(\text{mod}\ 5)=1$$。$$\mathbb{F}_p$$中的“除以$$a$$”是指乘$$a^{-1}$$。因此，如果$$p=5$$，那么在$$\mathbb{F}_p$$中，$$4/3=4\cdot 3^{-1}=4\cdot2=3$$。

​	在手稿的后面（例如15.1节），我们将利用下述事实：对于任意的素数幂（也即对$$p$$而言，$$p^k$$中的正整数$$k$$），有一唯一的大小为$$p^k$$的有限域，记为$$\mathbb{F}_{p^k}$$。

### 2.1.6 对Fact [2.1](#Fact2.1.)的解释

Fact [2.1](#Fact2.1.)事实上等同于下述事实：

<span id="Fact2.2.">**Fact 2.2.**</span> 任意非零且维数至多为$$n$$的多项式在任意域上至多有$$n$$个根。

​	对Fact [2.2](#Fact2.2.)的一个简单的证明是[[hp](https://math.stackexchange.com/users/677/dan petersen)]。为了说明Fact [2.2](#Fact2.2.)等价于Fact [2.1](#Fact2.1.)，注意到如果$$p_a$$和$$p_b$$是两个维数最多为$$n$$的不同的多项式，且最多只有$$n$$个$$x\in\mathbb{F}_p$$使得$$p_a(x)=p_b(x)$$，那么$$p_a-p_b$$就是非零且维数至多为$$n$$，但有多于$$n$$个根的多项式。